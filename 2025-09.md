# ** 9/1(月) **
### 【学習時間】
4.47h(累計:925.7h/1,000h)
  
### 【学習内容】
- java
- paiza
  
### 【課題を通して学んだこと】
- 参照型の型変換
    - 継承関係にあるクラス同士でオブジェクトの型変換が
        - サブ→スーパーへの変換：**自動**で行われる
        - スーパー→サブへの変換：**キャストで明示**する必要がある
    - `Person psn = stu1;`
        - 自動でサブクラス→スーパークラスに型変換される
        - psnには、stu1のオブジェクトの内、スーパークラスのオブジェクトのアドレスが格納される
    - `Student stu2 = (Student)psn;`
        - キャストでスーパークラス→サブクラスに型変換
        - stu2は、stu1のオブジェクトのアドレスが格納される
    - `instanceof`キーワード
        - オブジェクトのクラスを調べることが出来る
        - `対象オブジェクト instanceof クラス名`
            - `対象オブジェクト`が、その`クラス名`であるか否か?の意味
    - あくまで、型変換前のオブジェクトも型変換後のオブジェクトも同じオブジェクトを見ている
        - そのため、どちらかのオブジェクトで変数の中身を変えると、他方のオブジェクトの変数も同じ値に代わってしまう。
- 2種類の継承
    - クラス継承には2種類の考え方がある
        - 機能追加
        - 共通点まとめ
- 抽象クラスとポリモフィズム
    - 実装内容を持たないメソッドを**抽象メソッド**と呼ぶ
        - `abstract` を付ける
    - 抽象メソッドを持つクラスを**抽象クラス**と呼ぶ
        - `abstract` を付ける
        - インスタンス化は**不可**
    - 同じ抽象メソッドを呼び出しても、サブクラスによって挙動を変えることが出来る
        - **ポリモフィズム(多様性)**
    - ポリモフィズムの利点
        - サブクラスを作成する場合
            - メソッド名や書くべきメソッド・処理を統一させられる
                - メソッドの作成漏れを防げる
                - メソッド名の統一ができ、プログラムが見やすくなる
        - 呼び出し側のメリット
            - 呼び出し側の書き方も統一できる
                - サブクラスが増えても、呼び出し側は、修正の必要がない
- インターフェース
    - **定数**と**抽象メソッド**のみを定義できるクラスのテンプレート
        - 変数を定義すると自動で定数となる(`public static final`が自動で付く)
        - メソッドを定義すると自動で抽象メソッドとなる(`public abstract`が自動で付く)
    - インタフェースを**実装**したクラスでは、全てのメソッドの処理を定義する
        - 実装方法→(`implements`を入れる)
    - インタフェースは、複数実装できる
        - 実装は**色を付ける**イメージ(Gmailのタグ付けのようなイメージ)
- パッケージ
    - 複数のクラス等を1つのファイルに入れてまとめられる
    - `import 完全修飾名;` でインポートして利用
    - 宣言の順番
        - package宣言
        - import
        - classの定義
    - サンプルプログラム
        - コンパイル時
            - これまでは、実行用ファイルをコンパイルしていた
                - しかし、パッケージを先にコンパイルしないとエラーが出る
            - 一気にコンパイルする方法
                - `javac -d . *.java`
                    - -`d`オプション：パッケージ化したクラスがあった場合、**自動でディレクトリを作成**する
                    - `*.java`：現在のディレクトリの `.java` ファイルを全てコンパイル
        - java.ioパッケージ
            - ファイルへの入出力ができるパッケージ
- 例外
    - 実行時に発生するエラー：**例外**
    - 例外が発生すると**例外クラスのオブジェクトが自動生成**される
    - 全ての例外クラスは、 `Throwable`を継承している
    - 主な例外クラス
        - `Error`：システムが原因
            - メモリ不足で発生など
        - `Exception` ：プログラムが原因
            - `RuntimeException` ：どこでも発生しうるもの
    - `Exception` の内、ファイルの入出力周りなど、一部は例外処理を書く必要がある。(書かないとコンパイルエラー)
- 例外処理
    - 例外発生時に自動生成される例外オブジェクトを受け取るために、 `try-catch` ブロックを書く
        - `catch`ブロックは複数書ける
            - その場合は、サブクラスから先に書く
        - `finally`ブロック
            - 通常処理・エラー処理共通で走らせたい終了処理を記述できる
- throwとthrows
    - throw例外オブジェクト：例外を強制的に**発生**させる
    - throws例外クラス：メソッドがその例外を発生することを**宣言**する
        - エラーが発生した場合の処理は呼び出し側で書く(`try-cath`文を書く)
        - 複数の例外クラスの例外が発生する場合は、カンマ区切りで複数の例外クラスを記述できる
  

